# printf家族函数讲解

## sprintf函数

>  int sprintf( char *buffer, const char *format [, argument,...] ); 
>
> 除了前两个参数固定外，可选参数可以是任意个。buffer是字符数组名；format是格式化字符串（像："%3d%6.2f%#x%o",%与#合用时，自动在十六进制数前面加上0x）。只要在printf中可以使用的格式化字符串，在sprintf都可以使用。其中的格式化字符串是此函数的精华。

**eg: 将”test 1 2”写入数组s中** 

```c
#include<stdio.h>
int main(int argc, char *avgv[])
{
    char s[40];
    sprintf(s,"%s%d%c","test",1,'2');
    /*第一个参数就是指向要写入的那个字符串的指针，剩下的就和printf()一样了*/
    printf("%s", s);
    return 0;
}
```

**eg: 若”%s”等输出符在字符串中** 

```c
#include <iostream>
#include <stdio.h>
#include <cstring>

int main(int argc, char *argv[])
{
    char str[] = "hel%co wo%sd! sp%stf test%d";
    char buf[strlen(str)];
    sprintf(buf, str, 'l', "rl", "rin", 1);
    std::cout << "str = "<< buf << "\nlen = " <<  strlen(buf) << std::endl;
    return 0;
}

/*str = hello world! sprintf test1
len = 26*/
```

## fscanf和fprintf函数

> int fscanf ( FILE *fp, char * format, ... );
>
> ​	 **功能**：  从stream流中连续读取能够匹配format格式的字符到参数列表中对应的变量里。 
>
>  format参数允许的格式为：“%[*][width][modifiers]type”。[]中的内容根据需要供选，可缺省，%type必须要有，不可省。 
>
> int fprintf ( FILE *fp, char * format, ... );
>
>  fprintf() 返回成功写入的字符的个数，失败则返回负数。
>
> fscanf() 返回参数列表中被成功赋值的参数个数。 

```c
#include <stdio.h>
int main() {
　　FILE *in, *out;
　　if ((in = fopen("//AUTOEXEC.BAT", "rt")) == NULL) {
　　	fprintf(stderr, "Cannot open input file./n");
　　	return 1;
　　}
　　if ((out = fopen("//AUTOEXEC.BAK", "wt")) == NULL) {
　　	fprintf(stderr, "Cannot open output file./n");
　　	return 1;
　　}
　　while (!feof(in)) {fputc(fgetc(in), out);}
　　fclose(in);
　　fclose(out);
　　return 0;
}
```

eg:

```c
#include <stdio.h>
#include <process.h>
FILE *stream;
int main() {
　　int i = 10;
　　double fp = 1.5;
　　char s[] = "this is a string";
　　char c = '/n';
　　stream = fopen( "fprintf.out", "w" );
　　fprintf( stream, "%s%c", s, c );
　　fprintf( stream, "%d/n", i );
　　fprintf( stream, "%f/n", fp );
　　fclose( stream );
　　system( "type fprintf.out" );
}
/*
this is a string
10
1.500000
*/
```

## linux系统文件权限一道例题

> linux系统中文件权限为r,w,x；即可读，可写，可执行；现在已知一个文件的权限的总和（最大不超过7），权限总和即r+w+x的值，请输入一个权限总和，并且输入一个字符串；当可读时给字符串左右两边分别追加{}，可写时左右两边分别追加[], 可执行时左右两边分别追加（）。请使用c语言中的sprintf函数实现，不能使用c++。
> **输入样例：**
> 7
> hope
> **输出样例：**
> {[(hope)]}
> **解释：**7的二进制是111
> 也就是说从左往右看  分别是可读  可写  可执行 都为1  说明这三个都有
> 所以结果是{[(hope)]}

```c
#include <stdio.h>
#define swap(a, b) {\
     __typeof(a) __temp = a;\
    a = b; b = __temp;\
}
int main() {
    int n;
    scanf("%d",&n);//stdin
    printf("%d\n", n);//stdout
    char str[100] = {0}, buffer[100] = {0}, *p = str, *q = buffer;
    sprintf(str,"%d.%d.%d.%d",192, 168, 1, 10);
    printf("str = %s\n",str);
    if (n & 1) {
        sprintf(q, "(%s)", p);
        swap(q, p);
    }
    if (n & 2) {
        sprintf(q, "[%s]", p);
        swap(q, p);
    }
    if (n & 4) {
        sprintf(q, "{%s}", p);
        swap(q, p);
    }
    printf("%s\n", p);
    FILE *fout = fopen("./output", "w");
    fprintf(stdout, "stdout = %s\n", p);
    fprintf(stderr, "stderr = %s\n", p);
    return 0;
}
```

# 欧拉计划001

![](http://miracle0609.oss-cn-beijing.aliyuncs.com/miracle0609/img/1595936481410_A7EDF834-C48E-4d82-902B-D479F15BC3D9.png)

> **题目大意：**
>
> 如果我们列出 10 以下所有 3 或 5 的倍数的自然数，我们得到 3，5 ，6 和 9。这些倍数的总和是 23。
> 求 1000 以下 3 或 5 的所有倍数的总和。

![](http://miracle0609.oss-cn-beijing.aliyuncs.com/miracle0609/img/20200730124235.png)

**法一：时间复杂度O(n)**

```c
#include <stdio.h>

int is_val(int n) {
    return n % 3 == 0 || n % 5 == 0;
}

int main() {
    int sum = 0;
    for (int i = 1; i < 1000; i++) {
        if (is_val(i)) sum += i;
    }
    printf("%d\n", sum);
    return 0;
}
```

**法二：时间复杂度O(1)**

> 问题可转化为求1000以内以3为公差的等差数列的和+以5为公差的等差数列的和-以3和5的最小公倍数15为公差的等差数列的和。直接采用数学等差数列求和公式:
>
> n  * (a <sub>1</sub> + a <sub>n</sub>) / 2

```c
#include <stdio.h>

int main() {
    int sum3 = (3 + 999) * 333 / 2;
    int sum5 = (5 + 995) * 199 / 2;
    int sum15 = (15 + 999 / 15 * 15) * (999 / 15) / 2;
    //999/15表示1000以内有多少项
    printf("%d\n", sum3 + sum5 - sum15);
    return 0;
}
```

# 欧拉计划006

![](http://miracle0609.oss-cn-beijing.aliyuncs.com/miracle0609/img/20200730125555.png)

> 题目大意：
>
> 前十个自然数的平方和是385
> 		前十个自然数之和的平方是3025，
> 		因此，前十个自然数的平方和与之和的平方之差为3025-385=2640。
> 		找出前一百个自然数的平方和与和的平方的差。

**法一：**

```c
#include <stdio.h>

int main() {
    int sum1 = 0, sum2 = 0;
    for (int i = 1; i <= 100; i++) {
        sum1 += i * i;
        sum2 += i;
    }
    printf("%d\n", sum2 * sum2 - sum1);
    return 0;
}
```

**法二：**

![](http://miracle0609.oss-cn-beijing.aliyuncs.com/miracle0609/img/20200730142535.png)

```c
#include <stdio.h>
#define n 100

int main() {
    int sum2 = 5050;
    int sum1 = (2 * n * n * n + 3 * n * n + n) / 6;
    printf("%d\n", sum2 * sum2 - sum1);
    return 0;
}
```

